\documentclass[a4paper,10pt]{article}

\usepackage{graphicx}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings} 
\usepackage{float}
\usepackage[justification=centering]{caption}
\usepackage[T1]{fontenc}


\title{		\textbf{Trabajo práctico \#1: conjunto de instrucciones MIPS}}

\author{	Santiago Fernandez, \textit{Padrón Nro. 94.489}                     \\
            \texttt{ fernandezsantid@gmail.com }                                              \\[2.5ex]
            Francisco Landino, \textit{Padrón Nro. 94.475}                     \\
            \texttt{ landinofrancisco@gmail.com }                                              \\[2.5ex]
            Matias Duarte, \textit{Padrón Nro. 92.186}                     \\
            \texttt{ duarte.mati@gmail.com }                                              \\[2.5ex]
            \normalsize{2do. Cuatrimestre de 2014}                                      \\
            \normalsize{66.20 Organización de Computadoras  $-$ Práctica Jueves}  \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
       }
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}   % quita el número en la primer página


\begin{abstract}
Este trabajo práctico trata de una versión en lenguaje C, de un programa que lee desde un archivo de texto o desde STDIN, un texto que contiene tags, posiblemente anidados, y verifica que la estructura sea correcta. Además, se hizo un version en Assembly, de una función, para familiarizarse con el conjunto de instrucciones MIPS32 y el concepto de ABI.
\end{abstract}
\pagebreak 

\tableofcontents
\pagebreak

\section{Introducción}

\par Como objetivo de este trabajo practico se trabajo tanto usando el conjunto de instrucciones de MIPS32 como en el lenguaje C, para codificar un programa que recibe desde STDIN o desde un archivo de texto, un texto en el cual se encuentran tags, de la forma \emph{<Tag>... </Tag>}, posiblemente anidados. El programa se encarga de verificar que estén correctamente relacionados, lo que significa que el texto que abre un tag sea igual al texto que lo cierra y que estén correctamente anidados.
\par También se trabajo usando el ABI presentado por la cátedra, para guardar los argumentos en el stack entre las llamadas de función a función.

\section{Desarrollo}
\par Para desarrollar este trabajo primero se realizo un programa en lenguaje C, el cual contempla las siguientes condiciones.\\

\par Los \emph{tags} tienen que cumplir con la siguiente estructura:

\begin{itemize}
  \item Todos los \emph{tags} abiertos se cierran,
  \item Todos los \emph{tags} que se cierran fueron abiertos.
  \item Todos los \emph{tags} abiertos dentro de otro \emph{tag} se cierran antes que  ?este.
  \item Si se detecta una violación de alguna de las reglas anteriores, se especifica el error (\emph{tag} sin cerrar, \emph{tag} sin abrir, \emph{tag} mal anidado) y el numero de línea (empezando por 0) por \textbf{stderr}. En caso de que la estructura del archivo sea valida, el programa debe devolver 0, caso contrario devolver 1, ademas de la salida por \textbf{stderr}.
\end{itemize} 

Un \emph{tag} esta compuesto por una secuencia de apertura, de la forma\\ "\textbf{<nombre-tag>}", un contenido que puede ser texto u otros \emph{tags}, y una secuencia de cierre de la forma "\textbf{</nombre-tag>}".

\par Se considera que no pueden haber caracteres del tipo \emph{'<'} o \emph{'>'} sin que implique una apertura o cierre de un \emph{tag}.\\

\par Luego a partir de esta implementacion en C, se desarrollaron las funciones \emph{validate} y \emph{analizarTag} en Assembly MIPS32. Para dicha implementación se uso el ABI que enseño la cátedra durante las clases. Al principio de cada función se crea un stack, donde se guardan los registros del Return Address, Frame Pointer y Global Pointer en las posiciones mas grandes del stack. Luego se guardan los atributos de la función y finalmente los argumentos.

\subsection{Recursos y Portabilidad}

Uno de los objetivos del trabajo práctico es poder probar la portabilidad del
programa en diferentes entornos. En el enunciado se pedía que el programa se pudiera ejecutar en NetBSD[4]/pmax (usando el simulador GXemul[5]) y en la versión
de Linux (Knoppix, RedHat, Debian, Ubuntu) usada para correr el simulador,
Linux/i386. En particular, se lo probó en Ubuntu 14.04. En GXemul se corrió una máquina de arquitectura MIPS cuyo sistema operativo era una versión reciente de NetBSD/pmax. La transferencia de archivos entre la máquina host y la guest se hizo mediante \textit{SSH}. Se procedió de la siguiente manera:

Para trabajar con el GXemul se procedió primero creando una nueva interfaz de red (debe crearse cada vez que se inicia el \textit{host} y con permisos de administrador):
\\

\emph{hostOS\$ sudo ifconfig lo:0 172.20.0.1}
\\

Luego se ejecutó el GXemul en modo X:
\\

\emph{hostOS\$ ./xgxemul -e 3max -d netbsd-pmax.img -x}
\\

Una vez ya ingresado con el usuario y la contraseña en la máquina simulada,
se creó un túnel reverso para saltear las limitaciones propias del GXemul:
\\

\emph{guestOS\$ ssh -R 2222:127.0.0.1:22 usuario@172.20.0.1}
\\

A partir de ese momento y dejando lo anterior en segundo plano, ya se puedo
trabajar mediante SSH de manera más cómoda:
\\

\emph{hostOS\$ ssh -p 2222 root@127.0.0.1}
\\

\subsection{Implementación}
\par El programa en lenguaje C, cuenta con dos archivos: \emph{main.c} y \emph{validate.c}. \\
\par En el archivo \emph{main.c} se encuentran tres funciones:\\
 \par \emph{void cargarArchivoAMemoria(FILE* archivoEntrada, char* text)} \\
\par Se encarga de pasar el archivo de entrada a memoria. Por \emph{archivoEntrada} se pasa el puntero al archivo y por \emph{text} se obtiene el puntero a la cadena de texto en memoria.\\

\par \emph{void printManual()} \\
\par Imprime el manual sobre como usar el programa.\\

\par \emph{void checkFile(FILE* file)}\\
\par Verifica si el archivo del cual se quiere levantar es correcto.
\\
\par Luego en el main el programa se encarga de procesar todas las opciones, que se le introducen por argumento, y en el caso de que se pueda levantar el texto correctamente, llama a la función \emph{int validate(char *text, char **errmsg)} la cual se encarga de validar el archivo. Si validate devuelve 0, el programa imprime un 0 y termina su ejecución, pero si validate devuelve un 1, imprime un 1, junto con el mensaje de error en errmsg.\\

\par En el archivo \emph{validate.c} se encuentran dos funciones:\\

\par \emph{int analizarTag(char* text, char* tagEncontrado, int pos, int *contadorLineas)}\\

\par Analiza que el tag que le pasan por argumento sea igual al próximo tag que se cierra. Si encuentra que se abre otro tag antes de encontrar que se cierra un tag, levanta el tag anidado y se llama recursivamente para que lo verifique.

\par \emph{text} es el puntero al texto que se esta analizando.
\par \emph{tagEncontrado} es el puntero a la cadena de texto que contiene el tag que se levanto anteriormente y que hay que comparar con el siguiente tag que se cierre.
\par \emph{pos} es la posición a partir de la cual hay que ir analizando el texto. 
\par \emph{contadorLineas} es el puntero al contador que lleva el numero de linea.
\\
\par La función devuelve:
\par \emph{-1} si es un error donde el ultimo tag abierto no fue cerrado.
\par	 \emph{-2} si es un error donde el tag cerrado no corresponde con el tag abierto.
\par Sino devuelve un numero mayor a cero, el cual indica la posición del texto donde quedo después de analizar que se cerro correctamente el tag.\\\\\\

\par \emph{int validate(char *text, char **errmsg)}\\
\par Va recorriendo el texto hasta que encuentre el fin o hasta que encuentre un tag. Cuando encuentra un tag, lo guarda en el atributo \emph{tagALevantar} y luego llama a la función \emph{analizarTag} para que verifique si se cierra correctamente. Si analizar tag devuelve en un numero mayor a cero, continua analizando el texto desde esa posición, sino verifica que tipo de error es y devuelve por errmsg, el mensaje que se va a imprimir.\\
\par \emph{text} es el puntero al texto a verificar.
\par \emph{errmsg} es el puntero a la cadena de texto donde se tiene que guardar el mensaje de error en el caso de que haya alguno error en la estructura de los tags en el texto.\\
\par La función devuelve un 0 si llego al fin del texto y no se encontró ningún error, con la estructura de los tags, o devuelve un 1 si se encontró algún error.

\subsection{Compilación}

Para compilar el trabajo práctico, se tiene que ejecutar la siguiente línea en la terminal de Linux.\\
\\
\emph{gcc -Wall -pedantic -std=c99 main.c auxiliares.c -I / -o tp0}\\

Para simplificar este proceso, y no tener que escribir el comando entero, se creó un archivo \emph{compile.sh}, mediante el cual, con solo escribir \emph{./compile.sh}, se compila el trabajo práctico.

\subsection{Corrida de Pruebas}

\par Hicimos corridas con diferentes textos y los resultados fueron los siguientes.

\begin{lstlisting}
Texto 1:

<Tag1> texto </Tag1>
<Tag2>  texto2  </Tag2>
<Tag3> texto3 </tag>

Resultado:

1
Linea: 2. Tag mal anidado, el ultimo tag cerrado, no 
corresponde con el ultimo tag abierto.

Texto 2:

<Tag1> texto </Tag1>
<Tag2>  texto2  </Tag2>
<Tag3> <otroTag> <italic> texto3 </italic> </otroTag> </Tag3> texto4 </Tag5>

Resultado:

1
Linea: 2. El tag abierto, no fue cerrado.

Texto 3:

<Tag1> texto </Tag1>
<Tag2>  texto2  </Tag2>
<Tag3> <Bold> <UP> texto3 </UP> </Bold> </Tag3>

Resultado:

0

\end{lstlisting}

\pagebreak

\section{Diagrama de Stack}
\subsection{Validate}
 Stack Size Validate  56
\begin{table}[h]
\begin{tabular}{|l|l|} \hline
 **errmsg&  60&  \\	\hline
 *text&  56&  \\ \hline
 Padding  &50&   \\ \hline
 RA&  48&  \\ \hline
 FP&  44&  \\ \hline
 GP&  40&  \\ \hline
 VALIDATE RT&  36&  \\ \hline
 VALIDATE BF&  32&  \\ \hline
 VALIDATE TAGL&  28&  \\ \hline
 VALIDATE J&  24&  \\ \hline
 VALIDATE CL&  20&  \\ \hline
 VALIDATE I&  16&  \\ \hline
 ABA3&  12&  \\ \hline
 ABA2&  8&  \\ \hline
 ABA1&  4&  \\	\hline
 ABA0&  0&  \\ \hline
\end{tabular}
\end{table} \\

\newpage

\subsection{Analizar Tag}
 Stack Size Analizar Tag 40
\begin{table}[h]
\begin{tabular}{|l|l|} \hline
 Contador Lineas  & 52&  \\ \hline
 Posicion  & 48&  \\ \hline
 Tag Encontrado  & 44&  \\ \hline
 *text  & 40&  \\ \hline
 Padding  &36&   \\ \hline
 RA  &32&  \\ \hline
 FP  &28&  \\ \hline
 GP  &24&  \\ \hline
 VAR AUX  &20&  \\ \hline
 TAGALEVANTAR  &16&  \\ \hline
 ABA3  &12&  \\ \hline
 ABA2  &8&  \\ \hline
 ABA1  &4&  \\ \hline
 ABA0  &0&  \\ \hline
\end{tabular}
\end{table}

\newpage
\section{Conclusiones}

\par De este trabajo practico se pudo aprender como programar con el conjunto de instrucciones Assembly de MIPS32, asi como tambien la utilizacion correcta de la ABI de la catedra, entendiendo de esta manera como funciona una computadora a bajo nivel.

\newpage
\section{Referencias}
\noindent[1] GXemul, http://gavare.se/gxemul/.\\ \relax
[2] The NetBSD project, http://www.netbsd.org/.\\ \relax
[3] System V application binary interface, MIPS RISC processor supplement(third edition). Santa Cruz Operations, Inc.\\ \relax
[4] func call conv.pdf, en el area de Material de los archivos del grupo de Yahoo.\\ \relax

\end{document}