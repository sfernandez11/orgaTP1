\documentclass[a4paper,10pt]{article}

\usepackage{graphicx}
\usepackage[ansinew]{inputenc}
\usepackage[spanish]{babel}
\usepackage{listings} 
\usepackage{float}
\usepackage[justification=centering]{caption}
\usepackage[T1]{fontenc}


\title{		\textbf{Trabajo práctico \#1: conjunto de instrucciones MIPS}}

\author{	Santiago Fernandez, \textit{Padrón Nro. 94.489}                     \\
            \texttt{ fernandezsantid@gmail.com }                                              \\[2.5ex]
            Francisco Landino, \textit{Padrón Nro. 94.475}                     \\
            \texttt{ landinofrancisco@gmail.com }                                              \\[2.5ex]
            Matias Duarte, \textit{Padrón Nro. 92.186}                     \\
            \texttt{ duarte.mati@gmail.com }                                              \\[2.5ex]
            \normalsize{2do. Cuatrimestre de 2014}                                      \\
            \normalsize{66.20 Organización de Computadoras  $-$ Práctica Jueves}  \\
            \normalsize{Facultad de Ingeniería, Universidad de Buenos Aires}            \\
       }
\date{}

\begin{document}

\maketitle
\thispagestyle{empty}   % quita el número en la primer página


\begin{abstract}
Este trabajo práctico trata de una versión en lenguaje C, de un programa que lee un desde un archivo de texto o desde STDIN, un texto que contiene tags, posiblemente anidados, y verifica que la estructura sea correcta. Además, se hizo un version en Assembly, de una función, para familiarizarse con el conjunto de instrucciones MIPS32 y el concepto de ABI.
\end{abstract}
\pagebreak 

\tableofcontents
\pagebreak

\section{Introducción}

\par Como objetivo de este trabajo practico se trabajo tanto usando el conjunto de instrucciones de MIPS32 como en el lenguaje C, para programar un programa que recibe desde STDIN o desde un archivo de texto, un texto en el cual se encuentran tags, de la forma \emph{<Tag>... </Tag>}, posiblemente anidados. El programa se encarga de verificar que estén correctamente relacionados, lo que significa que el texto que abre un tag sea igual al texto que lo cierra y que estén correctamente anidados.
\par También se trabajo usando el ABI presentado por la cátedra, para guardar los argumentos entre las llamadas de función a función.

\section{Desarrollo}
\par Para desarrollar este trabajo primero se realizo un programa en lenguaje C, el cual contempla las siguientes condiciones.\\

\par Los \emph{tags} tienen que cumplir con la siguiente estructura:

\begin{itemize}
  \item Todos los \emph{tags} abiertos se cierran,
  \item Todos los \emph{tags} que se cierran fueron abiertos.
  \item Todos los \emph{tags} abiertos dentro de otro \emph{tag} se cierran antes que  ?este.
  \item Si se detecta una violación de alguna de las reglas anteriores, se especifica el error (\emph{tag} sin cerrar, \emph{tag} sin abrir, \emph{tag} mal anidado) y el numero de línea (empezando por 0) por \textbf{stderr}. En caso de que la estructura del archivo sea valida, el programa debe devolver 0, caso contrario devolver 1, ademas de la salida por \textbf{stderr}.
\end{itemize} 

Un \emph{tag} esta compuesto por una secuencia de apertura, de la forma\\ "\textbf{<nombre-tag>}", un contenido que puede ser texto u otros \emph{tags}, y una secuencia de cierre de la forma "\textbf{</nombre-tag>}".

\par Se considera que no pueden haber caracteres del tipo \emph{'<'} o \emph{'>'} sin que implique una apertura o cierre de un \emph{tag}.\\

\par Luego a partir de esta implementacion en C, se desarrollaron las funciones \emph{validate} y \emph{analizarTag} en Assembly MIPS32. Para dicha implementación se uso el ABI que enseño la cátedra durante las clases. Al principio de cada función se crea un stack, donde se guardan los registros del Return Address, Frame Pointer y Global Pointer en las posiciones mas grandes del stack. Luego se guardan los atributos de la función y finalmente los argumentos.

\subsection{Recursos y Portabilidad}

Uno de los objetivos del trabajo práctico es poder probar la portabilidad del
programa en diferentes entornos. En el enunciado se pedía que el programa se pudiera ejecutar en NetBSD[4]/pmax (usando el simulador GXemul[5]) y en la versión
de Linux (Knoppix, RedHat, Debian, Ubuntu) usada para correr el simulador,
Linux/i386. En particular, se lo probó en Ubuntu 14.04. En GXemul se corrió una máquina de arquitectura MIPS cuyo sistema operativo era una versión reciente de NetBSD/pmax. La transferencia de archivos entre la máquina host y la guest se hizo mediante \textit{SSH}. Se procedió de la siguiente manera:

Para trabajar con el GXemul se procedió primero creando una nueva interfaz de red (debe crearse cada vez que se inicia el \textit{host} y con permisos de administrador):
\\

\emph{hostOS\$ sudo ifconfig lo:0 172.20.0.1}
\\

Luego se ejecutó el GXemul en modo X:
\\

\emph{hostOS\$ ./xgxemul -e 3max -d netbsd-pmax.img -x}
\\

Una vez ya ingresado con el usuario y la contraseña en la máquina simulada,
se creó un túnel reverso para saltear las limitaciones propias del GXemul:
\\

\emph{guestOS\$ ssh -R 2222:127.0.0.1:22 usuario@172.20.0.1}
\\

A partir de ese momento y dejando lo anterior en segundo plano, ya se puedo
trabajar mediante SSH de manera más cómoda:
\\

\emph{hostOS\$ ssh -p 2222 root@127.0.0.1}
\\

\subsection{Implementación}
\par El programa en lenguaje C, cuenta con dos archivos: \emph{main.c} y \emph{validate.c}. \\
\par En el archivo \emph{main.c} se encuentran tres funciones:\\
 \par \emph{void cargarArchivoAMemoria(FILE* archivoEntrada, char* text)} \\
\par Se encarga de pasar el archivo de entrada a memoria. Por \emph{archivoEntrada} se pasa el puntero al archivo y por \emph{text} se obtiene el puntero a la cadena de texto en memoria.\\

\par \emph{void printManual()} \\
\par Imprime el manual sobre como usar el programa.\\

\par \emph{void checkFile(FILE* file)}\\
\par Verifica si el archivo del cual se quiere levantar es correcto.
\\
\par Luego en el main el programa se encarga de procesar todas las opciones, que se le introducen por argumento, y en el caso de que se pueda levantar el texto correctamente, llama a la función \emph{int validate(char *text, char **errmsg)} la cual se encarga de validar el archivo. Si validate devuelve 0, el programa imprime un 0 y termina su ejecución, pero si validate devuelve un 1, imprime un 1, junto con el mensaje de error en errmsg.\\

\par En el archivo \emph{validate.c} se encuentran dos funciones:\\

\par \emph{int analizarTag(char* text, char* tagEncontrado, int pos, int *contadorLineas)}\\

\par Analiza que el tag que le pasan por argumento sea igual al próximo tag que se cierra. Si encuentra que se abre otro tag antes de encontrar que se cierra un tag, levanta el tag anidado y se llama recursivamente para que lo verifique.

\par \emph{text} es el puntero al texto que se esta analizando.
\par \emph{tagEncontrado} es el puntero a la cadena de texto que contiene el tag que se levanto anteriormente y que hay que comparar con el siguiente tag que se cierre.
\par \emph{pos} es la posición a partir de la cual hay que ir analizando el texto. 
\par \emph{contadorLineas} es el puntero al contador que lleva el numero de linea.
\\
\par La función devuelve:
\par \emph{-1} si es un error donde el ultimo tag abierto no fue cerrado.
\par	 \emph{-2} si es un error donde el tag cerrado no corresponde con el tag abierto.
\par Sino devuelve un numero mayor a cero, el cual indica la posición del texto donde quedo después de analizar que se cerro correctamente el tag.\\\\\\

\par \emph{int validate(char *text, char **errmsg)}\\
\par Va recorriendo el texto hasta que encuentre el fin o hasta que encuentre un tag. Cuando encuentra un tag, lo guarda en el atributo \emph{tagALevantar} y luego llama a la función \emph{analizarTag} para que verifique si se cierra correctamente. Si analizar tag devuelve en un numero mayor a cero, continua analizando el texto desde esa posición, sino verifica que tipo de error es y devuelve por errmsg, el mensaje que se va a imprimir.\\
\par \emph{text} es el puntero al texto a verificar.
\par \emph{errmsg} es el puntero a la cadena de texto donde se tiene que guardar el mensaje de error en el caso de que haya alguno error en la estructura de los tags en el texto.\\
\par La función devuelve un 0 si llego al fin del texto y no se encontró ningún error, con la estructura de los tags, o devuelve un 1 si se encontró algún error.

\subsection{Compilación}

Para compilar el trabajo práctico, se tiene que ejecutar la siguiente línea en la terminal de Linux.\\
\\
\emph{gcc -Wall -pedantic -std=c99 main.c auxiliares.c -I / -o tp0}\\

Para simplificar este proceso, y no tener que escribir el comando entero, se creó un archivo \emph{compile.sh}, mediante el cual, con solo escribir \emph{./compile.sh}, se compila el trabajo práctico.

\subsection{Corrida de Pruebas}

\par Hicimos corridas con diferentes textos y los resultados fueron los siguientes.

\begin{lstlisting}
Texto 1:

<Tag1> texto </Tag1>
<Tag2>  texto2  </Tag2>
<Tag3> texto3 </tag>

Resultado:

1
Linea: 2. Tag mal anidado, el ultimo tag cerrado, no 
corresponde con el ultimo tag abierto.

Texto 2:

<Tag1> texto </Tag1>
<Tag2>  texto2  </Tag2>
<Tag3> <otroTag> <italic> texto3 </italic> </otroTag> </Tag3> texto4 </Tag5>

Resultado:

1
Linea: 2. El tag abierto, no fue cerrado.

Texto 3:

<Tag1> texto </Tag1>
<Tag2>  texto2  </Tag2>
<Tag3> <Bold> <UP> texto3 </UP> </Bold> </Tag3>

Resultado:

0

\end{lstlisting}


\subsection{Código}
\subsubsection{Código en C}

\begin{lstlisting}[language=C, columns=flexible, breaklines=true, frame=single, title=Listing : main.c]

#include "validate.h"

void cargarArchivoAMemoria(FILE* archivoEntrada, char* text) 
{ 
	int actual = 0;
	while(!feof(archivoEntrada)){
		(text)[actual] = fgetc(archivoEntrada);
		actual++;					
	}	
	(text)[actual-1] = '\0';
}

//Funcion que imprime el manual del TP1
void printManual(){
	printf("Usage:\n validate -h\n");
	printf(" validate -V\n");
	printf(" validate [options] file\n");
	printf("Options:\n");
	printf(" -h, --help  	Prints usage information.\n");
	printf(" -V, --version 	Prints version information.\n");
	printf(" -i, --input 	Path to input file (-i - for stdin)\n");
	printf("Examples:\n");
	printf(" validate -i -\n");
	printf(" validate myfile.tagged\n");
	printf(" validate -i myfile.tagged\n");
}

//Funcion para comprobar que los archivos se abrieron bien.
void checkFile(FILE* file){
    if (file == NULL){
    	//Si hay error se escribe por stderr.
    	fprintf(stderr, "Error, nombre de archivo inexistente, el programa se cerrara.\n");
        exit(1); // Se cierra el programa y se devuelve 1 por error.
    }
}

//Funcion principal del TP1
int main(int argc, char* argv[]){

	int next_option;

	const char* const short_options = "i:hV";

	const struct option long_options[] = {

		{ "input",     	1, NULL, 'i' },
		{ "help",    	0, NULL, 'h' },
		{ "version",    0, NULL, 'V' },
		{ NULL,         0, NULL, 0   } /* Necesario al final del array.  */
	};

	//Aca por defecto se establecen algunos parametros.
	//Luego depende las opciones elegidas se van cambiando.
	FILE* archivoEntrada = stdin;
	const char* nombreArchivo;
	int ejecutar = 0;
	int flag;
	char* errmsg;
	int tamanio = 2048;
	char text[tamanio];

	//Procesamiento de los parametros de entrada.
	do {
		next_option = getopt_long(argc, argv, short_options, long_options, NULL);

		switch (next_option){

		case 'i':   /* -i, --input */
		/* Indica el archivo de entrada a utilizar (-i - for stdin) */
		if (strcmp(optarg, "-") != 0){
			nombreArchivo = optarg;
	    	archivoEntrada = fopen(nombreArchivo, "r");
			printf("\nArchivo actual: %s\n",nombreArchivo);
			checkFile(archivoEntrada);
			cargarArchivoAMemoria(archivoEntrada, text);
			fclose(archivoEntrada);
		}else {
			printf("\nProcesando por STDIN\n");
			cargarArchivoAMemoria(archivoEntrada, text);
		}
		ejecutar = 1;
		break;

		case 'h':   /* -h, --help */
		/* Imprime el menu de ayuda  */
		printManual();
		exit(0);
		break;

		case 'V':   /* -V, --version */
		/*  Prints version information.  */
		printf(" Version 1.0 del TP1\n");
		exit(0);
		break;

		case -1:    /* Se terminaron las opciones */
		break;

		default:    /* Opcion incorrecta */
		fprintf(stderr, "Error, opcion incorrecta, el programa se cerrara.\n");
		printManual(); //Se imprime el manual para que se vean las opciones correctas.
		exit(1);	// Se cierra el programa y se devuelve 1 por error.
		}
	} while (next_option != -1);

	if (argc == (optind + 1)){
		nombreArchivo = argv[optind];
		archivoEntrada = fopen(nombreArchivo, "r");
		//printf("\nArchivo actual: %s\n",nombreArchivo);
		checkFile(archivoEntrada);
		cargarArchivoAMemoria(archivoEntrada, text);
		fclose(archivoEntrada);
		ejecutar = 1;
	}

	//Arranca la ejecucion del programa.
	if (ejecutar){
		//printf("----ARRANCA----\n");
		//Se llama a la funcion validate.
		// *text es un puntero al texto contenido en el archivo.
		// **errmsg es un puntero a un array de caracteres, a llenar por la funcion validate en caso de error.
		//Se utiliza la variable flag para ver si hubo error o no en la validacion.
		//La funcion debe retornar 0 en caso de que la validacion sea correcta, o 1 en caso de que no.
		flag = validate(text,&errmsg);
		if (flag>0){
			fprintf(stderr, "1\n%s\n", errmsg);
			exit(1);
		} else {
			fprintf(stdout, "0\n");
		}

	} else {
		fprintf(stderr, "Error, accion invalida, el programa se cerrara.\n");
		printManual(); //Se imprime el manual para que se vean las opciones correctas.
		exit(1);	// Se cierra el programa y se devuelve 1 por error.
	}

    return 0;
}

\end{lstlisting}

\begin{lstlisting}[language=C, columns=flexible, breaklines=true, frame=single, title=Listing : validate.h]

#ifndef VALIDATE_H_
#define VALIDATE_H_

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <getopt.h>

int validate(char* text, char** errmsg);

#endif /* VALIDATE_H_ */

\end{lstlisting}

\begin{lstlisting}[language=C, columns=flexible, breaklines=true, frame=single, title=Listing : validate.c]

#include "validate.h"

int analizarTag(char* text, char* tagEncontrado, int pos, int *contadorLineas)
{
	while(text[pos] != '\0')
	{
		if(text[pos] == '\n')
		{
			(*contadorLineas)++;
		}
		if(text[pos] == '<')
		{
			pos++;
			// Si entra en cerrar un tag
			if(text[pos] == '/')
			{
				pos++;
				int j = 0;
				while((text[pos] != '>') && (tagEncontrado[j] == text[pos]))
				{
					j++;	pos++;
				}
				if((tagEncontrado[j] == '\0') && (text[pos] == '>') )
				{
					return pos;
				} else {
					return -2;
				}
			}  else {
				int contadorTag = pos;
				while(text[contadorTag] != '>')
				{
					contadorTag++;
				}
				contadorTag = contadorTag - pos;
				int k = 0;
				char* tagALevantar = malloc(sizeof(char)*contadorTag);
				while(text[pos] != '>')
				{
					tagALevantar[k] = text[pos];
					k++; pos++;
				}
				tagALevantar[k] = '\0';
				pos++;
				int posSiguiente;
				posSiguiente = analizarTag(text, tagALevantar, pos, contadorLineas);
				free(tagALevantar);
				switch(posSiguiente)
				{
				case -1:
					return -1;
					break;
				case -2:
					return -2;
					break;

				default:
					pos = posSiguiente;
					break;

				}
			}
		}
		pos++;
	}
	return -1;
}

int validate(char *text, char **errmsg){

	char* buffer;
	int i = 0;
	int contadorLineas = 0;

	while(text[i] != '\0')
	{
		if(text[i] == '\n')
		{
			contadorLineas++;
		}

		if(text[i] == '<')
		{
			i++;
			int j = 0;
			char* tagALevantar;
			while(text[i] != '>')
			{
				tagALevantar[j] = text[i];
				j++; i++;
			}
			tagALevantar[j] = '\0';
			i = analizarTag(text, tagALevantar, i, &contadorLineas);
			switch(i)
			{
			case -1:
				sprintf(buffer, "Linea: %d. El tag abierto, no fue cerrado.\n", contadorLineas);
				*errmsg = buffer;
				return 1;
				break;
			case -2:
				sprintf(buffer, "Linea: %d. Tag mal anidado, el ultimo tag cerrado, no corresponde con el ultimo tag abierto.\n", contadorLineas);
				*errmsg = buffer;
				return 1;
				break;

			default:
				break;

			}
		}
		i++;
	}
	return 0;
}

\end{lstlisting}

\newpage
\section{Conclusiones}

\par De este trabajo practico se pudo aprender como programar con el conjunto de instrucciones Assembly de MIPS32, con lo cual se pudo aprender como trabaja una computadora a bajo nivel.

\newpage
\section{Referencias}
\noindent[1] GXemul, http://gavare.se/gxemul/.\\ \relax
[2] The NetBSD project, http://www.netbsd.org/.\\ \relax
[3] System V application binary interface, MIPS RISC processor supplement(third edition). Santa Cruz Operations, Inc.\\ \relax
[4] func call conv.pdf, en el area de Material de los archivos del grupo de Yahoo.\\ \relax

\end{document}